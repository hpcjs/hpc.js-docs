---
sidebar_position: 2
---

# Julia Set Visualizer

Now that you've written your first program with HPC.js, we're going to do something a bit more interesting: visualizing fractals generated by complex numbers. We'll be assuming that you've completed and understood the previous tutorial. No knowledge of complex arithmetic is necessary; we'll be providing all the requisite background.

At the end of this tutorial, you'll have something looking like this. And trust us when we say it's easier than it looks!

![julia set](../../static/img/julia-set.png 'Julia Set')

## Background

### Complex Numbers Refresher

Complex numbers are numbers of the form `x + yi`, where `x` and `y` are floating point numbers and `i * i == -1`. It may not be obvious, but they are invaluable in describing an unbelievable number of phenomena in the real world. Since complex numbers are defined by pairs of floats, we can easily represent them using the `vec2` primitive.

Adding complex numbers is easy: `(a + bi) + (c + di) == (a + c) + (b + d)i`, just like `vec2`s.

Multiplying them is easy as well. Just apply the FOIL rule from algebra class: `(a + bi)(c + di)` = `(ac + adi + bci + bdi^2)`. Invoking the defining property of `i`, this expression becomes `(ac - bd) + (ad + bc)i`. This behaves a bit differently than the standard `vec2.times(vec2)`, which is why we have a special method for complex multiplication: `vec2.cplxTimes(vec2)`.

### Julia Sets

Consider the function `f(z) = z^2 + c`, where `z` and `c` are complex numbers. We could imagine applying this function multiple times, e.g. `f(f(z))`, `f(f(f(z)))`, etc. The study of Julia sets asks, "what happens to a given number `z` as we apply this function an infinite number of times?" Specifically, we're interested in if numbers blow up to infinity as we keep applying `f(z)`, or if they stay bounded.

For example, consider `z = 1, c = -1`:
`f(z) = 0`, `f(f(z)) = -1`, `f(f(f(z))) = 0`, `f(f(f(f(z)))) = -1`, etc. As we can see, it bounces between `0` and `-1` forever.

On the other hand, `z = 2, c = 1` blows up quickly: `f(z) = 5`, `f(f(z)) = 26`, `f(f(f(z))) = 677`, etc.

It's clear that once `z` gets big enough, this function is guaranteed to blow up. We've actually put a bound on it: once `z.length() > 2`, the function will certainly diverge. But we're not just interested in whether or not two values of `z` and `c` diverge, but also _how many iterations_ it takes them to diverge. Does it happen after 2 iterations, or 200?

If it seems like we've just thrown a bunch of math at you, don't worry. It was just to give you some background on what we'll be doing here, but there's very little complex math in the code, and it's all abstracted away into methods.

## The Plan

We're going to make a visualizer for Julia sets. Each pixel will determine the starting value of `z`, and the mouse position will determine the value of `c`, which will be the same for each pixel. Depending on how many iterations it takes for `f(z)` to blow up, we'll choose a different color. Namely, if it takes `n` iterations, we'll choose `colors[n % colors.length]`.

As you move your mouse around, you'll be able to see how the fractal changes depending on different `c` values.

:::info

We've gone ahead and created a Next.js scaffolding project so you can get going immediately. We'll be doing everything in the `async run()` function inside the `useEffect` hook. Once you've got that up and running, continue on to the tutorial!

:::

## Setting up the GPUInterface

Since we're drawing to a canvas, we'll need to retrieve it from the DOM first and set its size to fullscreen.

```ts
const canvas = document.querySelector('canvas')!;
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
```

We'll also need three uniform variables: a `vec2` tracking the mouse position, a `number` storing the maximum number of iterations we'll run, and a `scale` factor that brings us from screen space to complex space.

```ts
const gpu = new GPUInterface({
  uniforms: {
    mouse: vec2(0, 0),
    maxIters: 1000,
    scale: 1 / 200,
  },
});

await gpu.initialize();
```

## Creating the Kernel

### Functions

Next, we're going to create the kernel that actually draws our fractal.

The first thing we're going to add is a function that translate points from screen space to complex space. The formula looks something like this:

`z = (pixel - canvas.size / 2) * scale`

Because `(0, 0)` is in the top-left corner for the canvas, we shift over by half the canvas size to move `(0, 0)` to the origin. Then, we rescale by our `scale` factor. In code, this looks like the following:

```ts
const kernel = gpu.createKernel(inputs => {
  function screenToComplex(pix = types.vec2) {
    const size = inputs.canvas.size;
    const scale = inputs.uniforms.scale;

    return pix.minus(size.div(2)).times(scale);
  }
});
```

### Variable Setup

Now that we have our function code, we can set up the variables for our kernel using the uniform data. First we create our colors array:

```ts
const colors = array([
  vec3(66, 30, 15),
  vec3(25, 7, 26),
  vec3(9, 1, 47),
  vec3(4, 4, 73),
  vec3(0, 7, 100),
  vec3(12, 44, 138),
  vec3(24, 82, 177),
  vec3(57, 125, 209),
  vec3(134, 181, 229),
  vec3(211, 236, 248),
  vec3(241, 233, 191),
  vec3(248, 201, 95),
  vec3(255, 170, 0),
  vec3(204, 128, 0),
  vec3(153, 87, 0),
  vec3(106, 52, 3),
]);
```

We're going to run this kernel once for each pixel, so we can extract the pixel from the thread ID.

```ts
const pixel = inputs.threadId.xy;
const mouse = inputs.uniforms.mouse;
const maxIters = inputs.uniforms.maxIters;

let z = screenToComplex(pixel);
const c = screenToComplex(mouse);
```

### Iterating

In each iteration of our loop, we're going to apply `f(z) = z^2 + c`, `break` if `z.length() > 2`, and increment the loop counter. Normally we would use a `for` loop to iterate, but since we want to remember the number of iterations after the loop, we'll use a `while` loop instead.

```ts
let iter = 0;
while (iter < maxIters) {
  z = z.cplxTimes(z).plus(c);

  if (z.length() > 2) {
    break;
  }

  iter++;
}
```

### Coloring

Finally, we choose the color based on how many iterations it took to diverge. We'll make the color black if it diverged immediately, or if it never diverged.

```ts
let color = colors[iter % dim(colors)];

if (iter === 0 || iter === maxIters) {
  color = vec3(0, 0, 0);
}
```

To set the color on the canvas, we just have to call `inputs.canvas.setPixel`.

```ts
inputs.canvas.setPixel(pixel, color);
```

And that's the kernel code done! Now it's just a bit more until our program is complete.

## Updating the Mouse Position

We need to constantly supply our kernel with the current mouse position. We can do this with the `mousemove` event listener and `gpu.setUniforms`. We'll have to get the canvas bounding rect so our mouse coordinates are relative to the top-left of the canvas.

```ts
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  gpu.setUniforms({ mouse: vec2(x, y) });
});
```

## Running our Kernel

This is the final piece of the puzzle. We need to use `requestAnimationFrame` to draw just like in typical JavaScript canvas applications, and it's the same as always. To update the canvas after setting the pixels, we simply use `gpu.updateCanvas()`.

```ts
const draw = () => {
  kernel.run(canvas.width, canvas.height);
  gpu.updateCanvas();

  requestAnimationFrame(draw);
};

draw();
```

## Conclusion

That's it! If you did everything correctly, you should have a smooth animation of a Julia set evolving as you move your mouse across the screen. If it's a bit laggy, try decreasing `maxIters` to a few hundred. We also suggest setting `useCpu` to `true` in the `GPUInterface` constructor, just to see how big the speedup is from CPU to GPU. Remember, you're iterating a function 1000 times on millions of pixels, 60 times per second!
